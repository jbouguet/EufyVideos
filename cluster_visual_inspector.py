#!/usr/bin/env python3
"""
Cluster Visual Inspector

This tool provides a comprehensive visual interface for inspecting person clusters
generated by the enhanced clustering system. It allows manual review of clusters
to verify they contain the same person and identify any misclassifications.

Key Features:
- Visual grid display of all crops in each cluster
- Cluster quality metrics and statistics
- Export functionality for further analysis
- Batch processing of all clusters

Usage:
    python cluster_visual_inspector.py

The tool will:
1. Load the enhanced clustering results
2. Create visual grids for each cluster showing all crop images
3. Generate comprehensive cluster reports
4. Save results for manual review and validation
"""

import os
import json
import cv2
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple
import math
from datetime import datetime

from enhanced_person_clustering import EnhancedPersonCluster, EnhancedPersonClusterer
from person_embedding import PersonEmbedding
from logging_config import create_logger

logger = create_logger(__name__)


class ClusterVisualInspector:
    """
    Visual inspection tool for person clusters.
    
    Provides comprehensive visual analysis of clustering results including:
    - Grid views of all crops in each cluster
    - Quality metrics and statistics
    - Export functionality for manual review
    """
    
    def __init__(self, 
                 clusters_file: str,
                 crops_base_dir: str,
                 output_dir: str):
        """
        Initialize the visual inspector.
        
        Args:
            clusters_file: Path to enhanced_clusters.json
            crops_base_dir: Base directory containing crop images
            output_dir: Directory to save visual inspection results
        """
        self.clusters_file = clusters_file
        self.crops_base_dir = crops_base_dir
        self.output_dir = output_dir
        self.clusters = []
        
        # Create output directory
        os.makedirs(output_dir, exist_ok=True)
        
        logger.info(f"ClusterVisualInspector initialized:")
        logger.info(f"  Clusters file: {clusters_file}")
        logger.info(f"  Crops base dir: {crops_base_dir}")
        logger.info(f"  Output dir: {output_dir}")
    
    def load_clusters(self):
        """Load enhanced clusters from JSON file."""
        logger.info("Loading enhanced clusters...")
        
        with open(self.clusters_file, 'r') as f:
            data = json.load(f)
        
        self.clusters = []
        for cluster_data in data['clusters']:
            cluster = EnhancedPersonCluster(
                cluster_id=cluster_data['cluster_id'],
                cluster_size=cluster_data['cluster_size'],
                avg_similarity=cluster_data['avg_similarity'],
                min_similarity=cluster_data['min_similarity'],
                quality_score=cluster_data['quality_score']
            )
            
            # Load embeddings
            for emb_data in cluster_data['embeddings']:
                embedding = PersonEmbedding.from_dict(emb_data)
                cluster.embeddings.append(embedding)
            
            self.clusters.append(cluster)
        
        logger.info(f"Loaded {len(self.clusters)} clusters for inspection")
    
    def find_crop_image(self, embedding: PersonEmbedding) -> Optional[str]:
        """
        Find the crop image file for a given embedding.
        
        Args:
            embedding: PersonEmbedding object
            
        Returns:
            Path to crop image file or None if not found
        """
        # Construct expected crop filename from embedding metadata
        video_name = embedding.video_filename.replace('.mp4', '')
        frame_num = int(embedding.frame_number) if isinstance(embedding.frame_number, str) else embedding.frame_number
        
        # Handle track_id - extract numeric part if it's a complex string
        if isinstance(embedding.track_id, str):
            # Extract last number from strings like 'det_294_297_563_619_1246'
            import re
            track_match = re.findall(r'\d+', embedding.track_id)
            track_id = int(track_match[-1]) if track_match else 0
        else:
            track_id = int(embedding.track_id)
            
        crop_filename = f"{video_name}_frame-{frame_num:06d}_track-{track_id:03d}.jpg"
        
        # Look for crop in video-specific directory
        crop_path = os.path.join(self.crops_base_dir, video_name, crop_filename)
        if os.path.exists(crop_path):
            return crop_path
        
        # Alternative naming pattern
        crop_filename_alt = f"{video_name}_frame-{frame_num:06d}_detect-{track_id:03d}.jpg"
        crop_path_alt = os.path.join(self.crops_base_dir, video_name, crop_filename_alt)
        if os.path.exists(crop_path_alt):
            return crop_path_alt
        
        # Search more broadly - look for frame number and any track/detect pattern
        for video_dir in Path(self.crops_base_dir).iterdir():
            if video_dir.is_dir() and video_name in video_dir.name:
                for crop_file in video_dir.glob("*.jpg"):
                    # Match frame number - this is the most reliable identifier
                    if f"frame-{frame_num:06d}" in crop_file.name:
                        # Check if track_id or any pattern matches
                        if (str(embedding.track_id) in crop_file.name or
                            f"track-{track_id}" in crop_file.name or 
                            f"detect-{track_id}" in crop_file.name or
                            f"detect-{frame_num}" in crop_file.name):  # Use frame number as fallback
                            return str(crop_file)
        
        return None
    
    def load_crop_images(self, cluster: EnhancedPersonCluster) -> List[Tuple[np.ndarray, PersonEmbedding]]:
        """
        Load all crop images for a cluster.
        
        Args:
            cluster: EnhancedPersonCluster object
            
        Returns:
            List of (image, embedding) tuples
        """
        crop_images = []
        
        for embedding in cluster.embeddings:
            crop_path = self.find_crop_image(embedding)
            if crop_path:
                image = cv2.imread(crop_path)
                if image is not None:
                    # Convert BGR to RGB for matplotlib
                    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
                    crop_images.append((image_rgb, embedding))
                else:
                    logger.warning(f"Could not load image: {crop_path}")
            else:
                logger.warning(f"Could not find crop for embedding: {embedding.video_filename} frame {embedding.frame_number}")
        
        return crop_images
    
    def create_cluster_grid(self, cluster: EnhancedPersonCluster, save_path: str) -> bool:
        """
        Create a visual grid of all crops in a cluster.
        
        Args:
            cluster: EnhancedPersonCluster object
            save_path: Path to save the grid image
            
        Returns:
            True if successful, False otherwise
        """
        crop_images = self.load_crop_images(cluster)
        
        if not crop_images:
            logger.warning(f"No images found for cluster {cluster.cluster_id}")
            return False
        
        # Calculate grid dimensions
        n_images = len(crop_images)
        cols = min(8, n_images)  # Max 8 columns
        rows = math.ceil(n_images / cols)
        
        # Create figure
        fig_width = cols * 2.5
        fig_height = rows * 3 + 2  # Extra space for title and info
        fig, axes = plt.subplots(rows, cols, figsize=(fig_width, fig_height))
        
        if rows == 1:
            axes = axes.reshape(1, -1) if n_images > 1 else np.array([[axes]])
        elif cols == 1:
            axes = axes.reshape(-1, 1)
        
        # Add cluster information as title
        fig.suptitle(
            f"Cluster {cluster.cluster_id} - {cluster.cluster_size} crops\n"
            f"Quality: {cluster.quality_score:.3f}, Avg Sim: {cluster.avg_similarity:.3f}, "
            f"Min Sim: {cluster.min_similarity:.3f}",
            fontsize=14, fontweight='bold'
        )
        
        # Plot images
        for idx, (image, embedding) in enumerate(crop_images):
            row = idx // cols
            col = idx % cols
            ax = axes[row, col]
            
            ax.imshow(image)
            ax.set_title(
                f"Frame {embedding.frame_number}\n"
                f"Track {embedding.track_id}, Conf {embedding.confidence:.2f}\n"
                f"Quality {embedding.embedding_quality:.2f}",
                fontsize=8
            )
            ax.axis('off')
        
        # Hide unused subplots
        for idx in range(n_images, rows * cols):
            row = idx // cols
            col = idx % cols
            axes[row, col].axis('off')
        
        plt.tight_layout()
        plt.subplots_adjust(top=0.85)  # Make room for title
        
        # Save the grid
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        plt.close()
        
        logger.info(f"Created grid for cluster {cluster.cluster_id}: {save_path}")
        return True
    
    def create_cluster_summary_report(self) -> str:
        """
        Create a comprehensive summary report of all clusters.
        
        Returns:
            Path to the summary report file
        """
        report_path = os.path.join(self.output_dir, "cluster_summary_report.txt")
        
        with open(report_path, 'w') as f:
            f.write("PERSON CLUSTER VISUAL INSPECTION REPORT\n")
            f.write("=" * 60 + "\n\n")
            
            f.write(f"Generated: {datetime.now().isoformat()}\n")
            f.write(f"Total clusters: {len(self.clusters)}\n")
            f.write(f"Total embeddings: {sum(c.cluster_size for c in self.clusters)}\n\n")
            
            # Overall statistics
            f.write("CLUSTER STATISTICS\n")
            f.write("-" * 30 + "\n")
            
            if self.clusters:
                qualities = [c.quality_score for c in self.clusters]
                sizes = [c.cluster_size for c in self.clusters]
                avg_sims = [c.avg_similarity for c in self.clusters]
                min_sims = [c.min_similarity for c in self.clusters]
                
                f.write(f"Quality scores: min={min(qualities):.3f}, "
                       f"max={max(qualities):.3f}, avg={np.mean(qualities):.3f}\n")
                f.write(f"Cluster sizes: min={min(sizes)}, "
                       f"max={max(sizes)}, avg={np.mean(sizes):.1f}\n")
                f.write(f"Avg similarities: min={min(avg_sims):.3f}, "
                       f"max={max(avg_sims):.3f}, avg={np.mean(avg_sims):.3f}\n")
                f.write(f"Min similarities: min={min(min_sims):.3f}, "
                       f"max={max(min_sims):.3f}, avg={np.mean(min_sims):.3f}\n\n")
            
            # Detailed cluster information
            f.write("DETAILED CLUSTER ANALYSIS\n")
            f.write("-" * 40 + "\n\n")
            
            # Sort clusters by quality score (highest first)
            sorted_clusters = sorted(self.clusters, key=lambda x: x.quality_score, reverse=True)
            
            for i, cluster in enumerate(sorted_clusters, 1):
                f.write(f"CLUSTER {cluster.cluster_id} (Rank #{i})\n")
                f.write(f"  Size: {cluster.cluster_size} crops\n")
                f.write(f"  Quality Score: {cluster.quality_score:.3f}\n")
                f.write(f"  Average Similarity: {cluster.avg_similarity:.3f}\n")
                f.write(f"  Minimum Similarity: {cluster.min_similarity:.3f}\n")
                
                # Video distribution
                videos = {}
                for emb in cluster.embeddings:
                    video = emb.video_filename
                    videos[video] = videos.get(video, 0) + 1
                
                f.write(f"  Video Distribution:\n")
                for video, count in sorted(videos.items()):
                    f.write(f"    {video}: {count} crops\n")
                
                # Quality distribution
                qualities = [emb.embedding_quality for emb in cluster.embeddings]
                confidences = [emb.confidence for emb in cluster.embeddings]
                
                f.write(f"  Embedding Quality: min={min(qualities):.3f}, "
                       f"max={max(qualities):.3f}, avg={np.mean(qualities):.3f}\n")
                f.write(f"  Detection Confidence: min={min(confidences):.3f}, "
                       f"max={max(confidences):.3f}, avg={np.mean(confidences):.3f}\n")
                
                f.write(f"  Grid Image: cluster_{cluster.cluster_id:03d}_grid.png\n\n")
        
        logger.info(f"Summary report saved: {report_path}")
        return report_path
    
    def create_inspection_index(self) -> str:
        """
        Create an HTML index file for easy visual inspection.
        
        Returns:
            Path to the HTML index file
        """
        index_path = os.path.join(self.output_dir, "cluster_inspection_index.html")
        
        # Sort clusters by quality score (highest first)
        sorted_clusters = sorted(self.clusters, key=lambda x: x.quality_score, reverse=True)
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Person Cluster Visual Inspection</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .cluster {{ border: 1px solid #ccc; margin: 20px 0; padding: 15px; }}
                .cluster-header {{ background-color: #f5f5f5; padding: 10px; margin: -15px -15px 15px -15px; }}
                .stats {{ display: inline-block; margin-right: 20px; }}
                .grid-image {{ max-width: 100%; height: auto; border: 1px solid #ddd; }}
                .quality-high {{ color: #2e7d32; font-weight: bold; }}
                .quality-medium {{ color: #f57c00; font-weight: bold; }}
                .quality-low {{ color: #c62828; font-weight: bold; }}
            </style>
        </head>
        <body>
            <h1>Person Cluster Visual Inspection</h1>
            <p>Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}</p>
            <p>Total clusters: {len(self.clusters)} | Total embeddings: {sum(c.cluster_size for c in self.clusters)}</p>
            
            <h2>Instructions</h2>
            <ul>
                <li>Review each cluster to verify all crops show the same person</li>
                <li>Note any misclassifications or clusters that should be merged</li>
                <li>Quality scores: <span class="quality-high">High (>0.9)</span>, 
                    <span class="quality-medium">Medium (0.7-0.9)</span>, 
                    <span class="quality-low">Low (<0.7)</span></li>
            </ul>
        """
        
        for i, cluster in enumerate(sorted_clusters, 1):
            quality_class = ("quality-high" if cluster.quality_score > 0.9 
                           else "quality-medium" if cluster.quality_score > 0.7 
                           else "quality-low")
            
            grid_filename = f"cluster_{cluster.cluster_id:03d}_grid.png"
            
            html_content += f"""
            <div class="cluster">
                <div class="cluster-header">
                    <h3>Cluster {cluster.cluster_id} (Rank #{i})</h3>
                    <div class="stats">Size: {cluster.cluster_size}</div>
                    <div class="stats">Quality: <span class="{quality_class}">{cluster.quality_score:.3f}</span></div>
                    <div class="stats">Avg Sim: {cluster.avg_similarity:.3f}</div>
                    <div class="stats">Min Sim: {cluster.min_similarity:.3f}</div>
                </div>
                <img src="{grid_filename}" alt="Cluster {cluster.cluster_id} Grid" class="grid-image">
            </div>
            """
        
        html_content += """
        </body>
        </html>
        """
        
        with open(index_path, 'w') as f:
            f.write(html_content)
        
        logger.info(f"HTML inspection index saved: {index_path}")
        return index_path
    
    def run_full_inspection(self):
        """
        Run complete visual inspection of all clusters.
        
        This creates:
        1. Individual grid images for each cluster
        2. Summary report with statistics
        3. HTML index for easy browsing
        """
        logger.info("=" * 60)
        logger.info("CLUSTER VISUAL INSPECTION")
        logger.info("=" * 60)
        
        # Load clusters
        self.load_clusters()
        
        if not self.clusters:
            logger.error("No clusters found to inspect")
            return
        
        # Create grid images for each cluster
        logger.info("Creating cluster grid images...")
        successful_grids = 0
        
        for cluster in self.clusters:
            grid_filename = f"cluster_{cluster.cluster_id:03d}_grid.png"
            grid_path = os.path.join(self.output_dir, grid_filename)
            
            if self.create_cluster_grid(cluster, grid_path):
                successful_grids += 1
        
        logger.info(f"Created {successful_grids}/{len(self.clusters)} cluster grids")
        
        # Create summary report
        report_path = self.create_cluster_summary_report()
        
        # Create HTML index
        index_path = self.create_inspection_index()
        
        # Final summary
        logger.info("=" * 60)
        logger.info("VISUAL INSPECTION COMPLETED")
        logger.info("=" * 60)
        logger.info(f"Results saved to: {self.output_dir}")
        logger.info(f"  - {successful_grids} cluster grid images")
        logger.info(f"  - Summary report: {os.path.basename(report_path)}")
        logger.info(f"  - HTML index: {os.path.basename(index_path)}")
        logger.info("")
        logger.info("Next steps:")
        logger.info("1. Open cluster_inspection_index.html in your browser")
        logger.info("2. Review each cluster to verify same person")
        logger.info("3. Note clusters that should be merged or split")
        logger.info("4. Use cluster labeling tool for grouping")


def main():
    """Run cluster visual inspection."""
    
    # Configuration
    clusters_file = "/Users/jbouguet/Documents/EufySecurityVideos/record/person_recognition/enhanced_clustering/enhanced_clusters.json"
    crops_base_dir = "/Users/jbouguet/Documents/EufySecurityVideos/record/person_recognition/crops"
    output_dir = "/Users/jbouguet/Documents/EufySecurityVideos/record/person_recognition/visual_inspection"
    
    try:
        # Create visual inspector
        inspector = ClusterVisualInspector(clusters_file, crops_base_dir, output_dir)
        
        # Run full inspection
        inspector.run_full_inspection()
        
        return 0
        
    except Exception as e:
        logger.error(f"Visual inspection failed: {e}")
        import traceback
        traceback.print_exc()
        return 1


if __name__ == "__main__":
    exit(main())